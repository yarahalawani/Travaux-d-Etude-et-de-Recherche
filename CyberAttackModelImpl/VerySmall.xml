<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>//  global declarations .


// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

const int NU = -1; 

const int nbVar =1;
const int dnbVar = (nbVar&gt;0)? nbVar : 1;
const int NbStates = 4; // 0 == F, 1 == M, 2 == B, 3 == N

const int sF=0; const int sM=1; const int sB=2; const int sT=2; const int sN=3;//node states, F:functional, M:malware, B/T: bad==tainted data, N: non available, do nor change values !!!!!
const int mand=1; const int opt=0; const int transp=NU;
// old denomination const int pF=0; const int pP=1; const int pA=2; //attacker position
const int peer=0; const int mitm=1; const int side=2; //attacker position, new format
const int cU=0; const int cR=1; const int cK=2; // knode type , User space, Root, Kernel Space
const int user=0; const int root=1; const int kernel=2;
const int rA=0, rS=1; // application , system role
const int MaxUnitCost=100; // max unitary cost
//const int MaxInputWeight=10; // abandonned, too complex  
//const int MaxInputWeights=MaxInputWeight*10; // abandonned, too complex  
const int MaxRoles=10; // new max roles per components


broadcast chan startCh; // start sychro

chan reset; // used to reset nodes after an anomaly detection



const int nbNodes = 6; // component number


typedef struct {
    int[0,NbStates-1] locat; // 0 == F, 1 == M, 2 == B, 3 == N
} nodeState_t;  // node state, init all = F == 1


// Secrets originally stored

const bool StoredSecrets [nbNodes] [dnbVar]={
//	

	{false},	//Browser
	{false},	//Hacker
	{false},	//HttpSrv
	{false},	//Linux
	{false},	//Routing
	{false}	//Windows
};

const int NodesKernels [nbNodes] ={
5,-1,3,-1,-1,-1
};


// Stolen Secrets 
bool StolenSecrets[dnbVar]={false};



nodeState_t nodeState[nbNodes]={ 
{	sF } /* node: 0:Browser */,
{	sF } /* node: 1:Hacker */,
{	sF } /* node: 2:HttpSrv */,
{	sF } /* node: 3:Linux */,
{	sF } /* node: 4:Routing */,
{	sF } /* node: 5:Windows */
};

const int maxCosts=200;
int[-1,MaxUnitCost*20] costs=0;


int fallBackMode[nbNodes][3]= { // fallback number for sM, sB or sN locals
{NU,NU,NU} /* node: 0:Browser */,
{NU,NU,NU} /* node: 1:Hacker */,
{NU,NU,NU} /* node: 2:HttpSrv */,
{NU,NU,NU} /* node: 3:Linux */,
{NU,NU,NU} /* node: 4:Routing */,
{NU,NU,NU} /* node: 5:Windows */
};

void FallBack(int node_id, int[0,NbStates-1] locat) {

int mode=fallBackMode[node_id][locat-1];

if (mode==NU) return;

    return;
}</declaration>
	<template>
		<name x="5" y="5">Browsert</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 5; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 5;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{0,user,1,0,10,{NU,NU,NU},
		{//Roles
			{rA,mand,5,25,20,15,20},
			{rS,mand,NU,20,NU,1,10},
			{rS,mand,NU,10,NU,1,10}
		},
		{//Inputs
			{2,peer,0,false,{25,0,NU,NU}}	/* HttpSrv	*/,
			{3,mitm,0,false,{25,0,NU,NU}}	/* Linux	*/,
			{4,mitm,0,false,{25,0,NU,NU}}	/* Routing	*/,
			{5,mitm,0,false,{25,0,NU,NU}}	/* Windows	*/,
			{5,peer,2,false,{0,NU,NU,NU}}	/* Windows	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==1) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==2) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN);
	if (inp ==3) return ( nodeState[5].locat != sN);
	if (inp ==4) return ( nodeState[5].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id0" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id1" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id2" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id3" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id4" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id5" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id4"/>
		<transition id="id6" color="#c0c0c0">
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id7" color="#c0c0c0">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id8" color="#c0c0c0">
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id9" color="#c0c0c0">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id10">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id11">
			<source ref="id0"/>
			<target ref="id5"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id12">
			<source ref="id0"/>
			<target ref="id5"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id13">
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id14">
			<source ref="id0"/>
			<target ref="id5"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id15" color="#c0c0c0">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id16" color="#a9a9a9">
			<source ref="id4"/>
			<target ref="id0"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id17" color="#c0c0c0">
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id18" color="#c0c0c0">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id19">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id20">
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id21">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id22">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Hackert</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 3; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 1;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{1,kernel,1,0,10,{NU,NU,NU},
		{//Roles
			{rS,mand,NU,60,NU,50,50},
			{rS,mand,NU,20,NU,10,10},
			{rS,mand,NU,60,NU,50,50}
		},
		{//Inputs
			{2,peer,2,false,{0,NU,NU,NU}}	/* HttpSrv	*/,
			{3,peer,2,false,{0,NU,NU,NU}}	/* Linux	*/,
			{4,peer,2,false,{0,NU,NU,NU}}	/* Routing	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[1].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==1) return ( nodeState[1].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==2) return ( nodeState[1].locat != sN and  nodeState[4].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id23" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id24" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id25" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id26" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id27" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id28" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id27"/>
		<transition id="id29" color="#c0c0c0">
			<source ref="id25"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id30" color="#c0c0c0">
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id31" color="#c0c0c0">
			<source ref="id23"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id32" color="#c0c0c0">
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id33">
			<source ref="id23"/>
			<target ref="id23"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id34">
			<source ref="id23"/>
			<target ref="id28"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id35">
			<source ref="id23"/>
			<target ref="id28"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id36">
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id37">
			<source ref="id23"/>
			<target ref="id28"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id38" color="#c0c0c0">
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id39" color="#a9a9a9">
			<source ref="id27"/>
			<target ref="id23"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id40" color="#c0c0c0">
			<source ref="id27"/>
			<target ref="id24"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id41" color="#c0c0c0">
			<source ref="id27"/>
			<target ref="id25"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id42">
			<source ref="id25"/>
			<target ref="id25"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id43">
			<source ref="id23"/>
			<target ref="id26"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id44">
			<source ref="id23"/>
			<target ref="id24"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id45">
			<source ref="id23"/>
			<target ref="id25"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">HttpSrvt</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 6; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 3;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{2,user,1,0,10,{NU,NU,NU},
		{//Roles
			{rA,transp,5,25,20,15,20},
			{rS,mand,NU,20,NU,1,10},
			{rS,mand,NU,10,NU,1,10}
		},
		{//Inputs
			{0,peer,0,false,{25,0,NU,NU}}	/* Browser	*/,
			{1,side,0,false,{25,15,NU,NU}}	/* Hacker	*/,
			{3,mitm,0,false,{25,0,NU,NU}}	/* Linux	*/,
			{4,mitm,0,false,{25,0,NU,NU}}	/* Routing	*/,
			{5,mitm,0,false,{25,0,NU,NU}}	/* Windows	*/,
			{3,peer,2,false,{0,NU,NU,NU}}	/* Linux	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[3].locat != sN and  nodeState[4].locat != sN and  nodeState[5].locat != sN);
	if (inp ==1) return ( nodeState[3].locat != sN and  nodeState[4].locat != sN and  nodeState[1].locat != sN);
	if (inp ==2) return ( nodeState[3].locat != sN);
	if (inp ==3) return ( nodeState[3].locat != sN and  nodeState[4].locat != sN);
	if (inp ==4) return ( nodeState[3].locat != sN and  nodeState[4].locat != sN and  nodeState[5].locat != sN);
	if (inp ==5) return ( nodeState[3].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id46" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id47" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id48" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id49" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id50" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id51" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id50"/>
		<transition id="id52" color="#c0c0c0">
			<source ref="id48"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id53" color="#c0c0c0">
			<source ref="id49"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id54" color="#c0c0c0">
			<source ref="id46"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id55" color="#c0c0c0">
			<source ref="id47"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id56">
			<source ref="id46"/>
			<target ref="id46"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id57">
			<source ref="id46"/>
			<target ref="id51"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id58">
			<source ref="id46"/>
			<target ref="id51"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id59">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id60">
			<source ref="id46"/>
			<target ref="id51"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id61" color="#c0c0c0">
			<source ref="id50"/>
			<target ref="id49"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id62" color="#a9a9a9">
			<source ref="id50"/>
			<target ref="id46"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id63" color="#c0c0c0">
			<source ref="id50"/>
			<target ref="id47"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id64" color="#c0c0c0">
			<source ref="id50"/>
			<target ref="id48"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id65">
			<source ref="id48"/>
			<target ref="id48"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id66">
			<source ref="id46"/>
			<target ref="id49"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id67">
			<source ref="id46"/>
			<target ref="id47"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id68">
			<source ref="id46"/>
			<target ref="id48"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Linuxt</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 2; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 3;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{3,kernel,1,0,10,{NU,NU,NU},
		{//Roles
			{rS,mand,NU,60,NU,50,50},
			{rS,mand,NU,20,NU,10,10},
			{rS,mand,NU,60,NU,50,50}
		},
		{//Inputs
			{4,peer,2,false,{0,NU,NU,NU}}	/* Routing	*/,
			{2,peer,0,false,{0,NU,NU,NU}}	/* HttpSrv	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[3].locat != sN and  nodeState[4].locat != sN);
	if (inp ==1) return ( nodeState[3].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id69" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id70" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id71" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id72" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id73" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id74" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id73"/>
		<transition id="id75" color="#c0c0c0">
			<source ref="id71"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id76" color="#c0c0c0">
			<source ref="id72"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id77" color="#c0c0c0">
			<source ref="id69"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id78" color="#c0c0c0">
			<source ref="id70"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id79">
			<source ref="id69"/>
			<target ref="id69"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id80">
			<source ref="id69"/>
			<target ref="id74"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id81">
			<source ref="id69"/>
			<target ref="id74"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id82">
			<source ref="id74"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id83">
			<source ref="id69"/>
			<target ref="id74"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id84" color="#c0c0c0">
			<source ref="id73"/>
			<target ref="id72"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id85" color="#a9a9a9">
			<source ref="id73"/>
			<target ref="id69"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id86" color="#c0c0c0">
			<source ref="id73"/>
			<target ref="id70"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id87" color="#c0c0c0">
			<source ref="id73"/>
			<target ref="id71"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id88">
			<source ref="id71"/>
			<target ref="id71"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id89">
			<source ref="id69"/>
			<target ref="id72"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id90">
			<source ref="id69"/>
			<target ref="id70"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id91">
			<source ref="id69"/>
			<target ref="id71"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Routingt</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 5; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 4;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{4,kernel,1,0,10,{NU,NU,NU},
		{//Roles
			{rS,mand,NU,60,NU,50,50},
			{rS,mand,NU,20,NU,10,10},
			{rS,mand,NU,60,NU,50,50}
		},
		{//Inputs
			{0,peer,2,false,{0,NU,NU,NU}}	/* Browser	*/,
			{1,peer,2,false,{0,NU,NU,NU}}	/* Hacker	*/,
			{2,peer,2,false,{0,NU,NU,NU}}	/* HttpSrv	*/,
			{3,peer,2,false,{0,NU,NU,NU}}	/* Linux	*/,
			{5,peer,2,false,{0,NU,NU,NU}}	/* Windows	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[4].locat != sN and  nodeState[5].locat != sN);
	if (inp ==1) return ( nodeState[4].locat != sN and  nodeState[1].locat != sN);
	if (inp ==2) return ( nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==3) return ( nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==4) return ( nodeState[4].locat != sN and  nodeState[5].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id92" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id93" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id94" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id95" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id96" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id97" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id96"/>
		<transition id="id98" color="#c0c0c0">
			<source ref="id94"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id99" color="#c0c0c0">
			<source ref="id95"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id100" color="#c0c0c0">
			<source ref="id92"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id101" color="#c0c0c0">
			<source ref="id93"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id102">
			<source ref="id92"/>
			<target ref="id92"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id103">
			<source ref="id92"/>
			<target ref="id97"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id104">
			<source ref="id92"/>
			<target ref="id97"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id105">
			<source ref="id97"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id106">
			<source ref="id92"/>
			<target ref="id97"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id107" color="#c0c0c0">
			<source ref="id96"/>
			<target ref="id95"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id108" color="#a9a9a9">
			<source ref="id96"/>
			<target ref="id92"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id109" color="#c0c0c0">
			<source ref="id96"/>
			<target ref="id93"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id110" color="#c0c0c0">
			<source ref="id96"/>
			<target ref="id94"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id111">
			<source ref="id94"/>
			<target ref="id94"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id112">
			<source ref="id92"/>
			<target ref="id95"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id113">
			<source ref="id92"/>
			<target ref="id93"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id114">
			<source ref="id92"/>
			<target ref="id94"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Windowst</name>
		<parameter>int[0, nbNodes-1] id</parameter>
		<declaration>// Place local declarations here.

// This research has been carried out in IRT SystemX, Paris-Saclay, France, and therefore granted with public funds of the French Program “Investissements d’Avenir”.
// This code is published under license MIT : https://spdx.org/licenses/MIT.html

	const int NbInputs = 4; // per node
	const int diM = (NbInputs&gt;0)? NbInputs : 1;
    const int NbRoles = 3;
    const int kernelIndex = 5;
    const int diMr = (NbRoles&gt;0)? NbRoles : 1;

    typedef struct {
        int[NU,nbNodes-1] node_id; // input node id,  -1/NU not used
        int[NU,2] attack_position; // peer 0 , mitm 1 == ,side 2 
        int [0,diMr] roleId; // role id of attacked component, local id
        bool tunnelOn; // true if tunnel on
        int protCost[4];  // attack on protocols:  "0" session entrance cost (0 for peer), "1" break (down), tunnel compromission costs ("2" tunnel entrance, "3" tunnel break) , already adapted to the attacker position, NU for costs == impossible to break  
    } input_t; // input description, for each interaction
 
	
	typedef struct {
	    int[0,nbNodes-1] node_id;
 	    int[0, 2] node_type; // 0 == user space component , 1 == root space component, 2 == kernel
        int plausThreshold,actThreshold; // min of Bd roles to be bad data, min of active rA roles != 'mandatory' to be sF or sB , mandatory roles no included
	    int[NU,MaxUnitCost] secrTheftCost; // steal all the secrets stored locally, by already installed local malware 
        int AnomDetParam[3];  // 3 costs for bypassing anomaly detection : m, b, n, if &lt;0, monitoring disabled
        int RoleParams[diMr][7]; // role params, 7 values :  
                                    // 0 role type: rA==app rS==system, 
                                    // 1 importance (!= NU only for rA) Nu=='transparent' 0=='optional' 1=='mandatory',  
                                    // 2 bad data acceptability cost, 
                                    // 3,4,5 malware install costs :malware ,bad data only ,non available only,
                                    // 6 cost of theft of locally stored secrets by remote malware
	    input_t in[diM]; 
	} node_t; // node description, for topology

const int roleProtectKey[diMr][dnbVar]={
	{false},
	{false},
	{false}
};

	const node_t node =
	{5,kernel,1,0,10,{NU,NU,NU},
		{//Roles
			{rS,mand,NU,50,NU,40,50},
			{rS,mand,NU,20,NU,10,10},
			{rS,mand,NU,50,NU,40,50}
		},
		{//Inputs
			{2,peer,2,false,{0,NU,NU,NU}}	/* HttpSrv	*/,
			{3,peer,2,false,{0,NU,NU,NU}}	/* Linux	*/,
			{4,peer,2,false,{0,NU,NU,NU}}	/* Routing	*/,
			{0,peer,0,false,{0,NU,NU,NU}}	/* Browser	*/
		}
	};



 
     bool isFallBackActiv(int[0,nbNodes-1] NodeIndex,int[0,NbStates-1] Targetlocation) {
        return (node.AnomDetParam[Targetlocation-1] != NU) and ( fallBackMode[node.node_id][Targetlocation-1] !=NU);
    }


    /*bool key(int[0,nbNodes-1] sourceNodeIndex,int[0,nbVar-1] secrId) {
        int idKernel=NodesKernels[sourceNodeIndex];
        bool ret=StolenSecrets[secrId] or StoredSecrets[sourceNodeIndex][secrId];
        if (idKernel&gt;0) ret=ret or StoredSecrets[idKernel][secrId];
        return ret;
    }*/


    int ProtProtectCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2]; bool keyProtect=false;
        int kernelSId=NodesKernels[sourceNodeIndex];

        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCost=0;
            } // application protocol is set to zero if one of the protection secret is available
        }
        if (attack_position==peer) {if (keyProtect) return protCost;else return 0;} // special case for PF position, only application protocol is to consider
        if (node.in[inpId].tunnelOn) { if (protCost==NU or tunCost==NU) return NU; else return (protCost+tunCost); } else return protCost;
    }


    int ProtDestructCost(int[0,diM-1] inpId, int roleId, int[0,nbNodes-1] sourceNodeIndex,int[NU,2] attack_position) { // cost of protocol session theft
        int protCostBr=node.in[inpId].protCost[1],tunCostBr=node.in[inpId].protCost[3]; bool keyProtect=false;
        int protCost=node.in[inpId].protCost[0],tunCost=node.in[inpId].protCost[2];
        int kernelSId=NodesKernels[sourceNodeIndex];

        if (protCostBr==NU or (protCost!=NU and protCost&lt;protCostBr)) protCostBr=protCost; // normally it si easier to put down than enter, but we consider also the contray case
        for (i : int[0,nbVar-1] ) {
            if (roleProtectKey[roleId][i]) {
                bool kerSt=false;if (kernelSId !=NU) kerSt=StoredSecrets[kernelSId][i];
                keyProtect=true;if (StolenSecrets[i] or StoredSecrets[sourceNodeIndex][i] or kerSt) protCostBr=0;
            } // application protocol is set to zero if one of the protection secret is available
        }

        if (attack_position==peer) {if (keyProtect) return protCostBr;else return 0;} // special case for PF position, only application protocol is to consider if key is available

        if (node.in[inpId].tunnelOn) {
            if (tunCost==NU or protCostBr==NU or ( (tunCost+protCost) &gt; tunCostBr ) ) return tunCostBr; // impossible to enter tunnel 
            return (protCostBr+tunCostBr);
        } else return protCostBr; // no tunel only application prooc is to consider
    }


	
	bool reachable (int[0,diM-1] inp) { // true if this node can be visible by the input_node
	if (inp ==0) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==1) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN and  nodeState[3].locat != sN);
	if (inp ==2) return ( nodeState[5].locat != sN and  nodeState[4].locat != sN);
	if (inp ==3) return ( nodeState[5].locat != sN);
	    return false;
	} 


    int minBadDataCost() { // returns the sum of costs for all inputs capable of producing bad data, Nu if impossible 
        int[NU,MaxUnitCost] rolCostBd[diMr] = {NU,NU,NU};
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers
        
        int bdCost=0, tcost=NU, tr=0,totRolOK=0,totRolBd=0, mustcopromise=NU, nbCompr=0,activityCost=0; // tcost total min cost        
        int tr1=NU, j=NU;
	    if (NbInputs &lt;=0) return NU;if (node.node_type==cK) return NU;
       // for all no system inputs: we memorise potentiel B et M available attacker nodes and costs of B data submissions, B cost in composed from two values, session breaking and acceptable bad data generation, sum of Ok Weight 
       // first round, minimal costs  for available partners 
	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][0]!=rS) and (node.RoleParams[node.in[i].roleId][1]!=transp)) { // available inputs,  no system and important roles only
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int costDir=node.RoleParams[role][2], protCost=ProtProtectCost(i,role,node.in[i].node_id,attack_position), tt=NU; // costDir : cost of creation of acceptable data by role, protCost : cost of protocol break
           if ((protCost==NU) or (costDir==NU)) tt=NU; else tt=costDir+protCost;
           if ( (tt!=NU) and ( (attackerState==sM) or ( (attackerState==sB) and (attack_position==peer) ) ) ) if (rolCostBd[role]==NU or rolCostBd[role]&gt;tt) rolCostBd[role]=tt; // looking for the minimal cost of roles !!!!!!!!!!!!!!!!
           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;
	 	}
        // number of roles OK and potentially compromisable, compliance with mandatory roles
        for(role : int[0,diMr-1] ) if (node.RoleParams[role][0]!=rS) { //no system roles
            if ( node.RoleParams[role][1]==mand) {  // mandatory role
                if ( (rolCostBd[role]&lt;=NU) and not rolOk[role] ) return NU; // impossible to compromise not active mandatory role
                if (not rolOk[role] ) mustcopromise = (mustcopromise&gt;NU)?mustcopromise+rolCostBd[role]:rolCostBd[role]; // cost of compromission of all manadatrory and not OK roles
                if ( (tcost==NU) or (rolCostBd[role]&lt;tcost) ) tcost=rolCostBd[role]; // minimal cost of  the compromissions of one of the mandatory role =&gt; tcost 
            } else if ( (node.RoleParams[role][1]==0) and rolOk[role] ) totRolOK++; //number of OK optionnal roles
        }

        //if ( (totRolBmf + totRolOK) &lt; node.actThreshold ) return NU; // no enough of OK or possible to compromise  optional roles, i.e. not enough of possible active roles
        if ( (mustcopromise&gt;NU) and (totRolOK &gt;=node.actThreshold) ) return mustcopromise;
        
      // adding necessary non active optional roles for minimal activity
        nbCompr =node.actThreshold - totRolOK;
        activityCost=0;totRolBd=0;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and not rolOk[role] )  { //only optional, no system roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; totRolBd++; activityCost += tr1; rolCostBd[j]=NU; totRolOK++;}
        }   
        if (nbCompr&gt;0) return NU; // impossible to have enough active optional roles

       if (mustcopromise&gt;NU) return activityCost + mustcopromise; // no necessary to add supplementary optionnal role to achieve plausThreshold

       // adding necessary active optional roles for input bad data
        nbCompr =node.plausThreshold - totRolBd; // totRolBd === already compromised optional roles to maintain activity
        bdCost=NU;
        for(k : int[0,diMr-1] ) if (nbCompr&gt;0){ // for OK role only
          tr1=NU;
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==opt) and (rolCostBd[role] &gt; NU) and rolOk[role] )  { //only optional roles
            if ( (tr1==NU) or (tr1&gt;rolCostBd[role]) )  { tr1=rolCostBd[role]; j=role; } // role of min cost
          }
          if ( tr1!=NU ) { nbCompr--; if (bdCost!=NU) bdCost += tr1; else bdCost = tr1; rolCostBd[j]=NU; }
        }   

        if ( (nbCompr&gt;0) and (tcost&lt;0) ) return NU; // not enough of bad data and impossible to compromise manadatory roles  
        if (tcost&lt;0) {
            if (bdCost&lt;0) return activityCost;
            return activityCost + bdCost;
        }
        if (bdCost!=NU) return activityCost+(tcost&lt;bdCost)?tcost:bdCost;
        return activityCost+tcost;       
    }

    int BadData(int[NU,nbNodes-1] node_id, bool fallback) { // fallback == true if possible fallback will be thrown
        int badDataCost, suppl=0;
        if (fallback and not isFallBackActiv(node_id,sB) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        badDataCost=minBadDataCost();
        if (badDataCost == NU) return NU;
        badDataCost+=suppl;
        if ( (badDataCost+costs)&lt;= maxCosts ) return badDataCost;
        return NU;
    }

    void updateBadData(int[NU,nbNodes-1] node_id, bool fallback) {
        int badDataCost=minBadDataCost(), suppl=0;
        if ( (not fallback) and  isFallBackActiv(node_id,sB) ) suppl=node.AnomDetParam[sB-1];
        costs += badDataCost+suppl;
        if (not fallback) nodeState[node_id].locat=sB;
    }


    int minNonDispCost() { // returns the sum of costs for all inputs able to produce Non availability state (sN), Nu if impossible 
        int[NU,MaxUnitCost] rolCostBdM[diMr] = {NU,NU,NU}; // 
        bool rolOk[diMr] = {false,false,false};  // true if a role can stay OK thanks to legitimate producers, "no system roles only" are considered
        int nbOKnMand=0, tcost=NU, nbtocomp=0;// tcost total min cost 
        int bdCost=NU,tr=NU;
  

        // "N" malware installation is considered in the  MinCostMalware function    
 
	    if (NbInputs &lt;=0) return NU;

        // for all "no system" inputs: we memorise potentiel B et M available attacker nodes and costs of non acceptable data submissions or (for M only) session destruction, this cost 0 for peer position and session breaking for others


	 	for(i : int[0,diM-1] ) if ( reachable(i) and (node.RoleParams[node.in[i].roleId][1]!=NU) and (node.RoleParams[node.in[i].roleId][0]!=rS) ) { // reachable  and important  
           int[0,NbStates-1] attackerState=nodeState[node.in[i].node_id].locat;
           int[0,diMr-1] role = node.in[i].roleId; 
           int[NU,2] attack_position=node.in[i].attack_position;
           int sessDestruct=NU;

           if ( (attackerState==sF) and (attack_position==peer) ) rolOk[role]=true;

           if (rolCostBdM[role]!=0) {
                    sessDestruct=ProtDestructCost(i,role,node.in[i].node_id,attack_position);
                    if (sessDestruct != NU) { if (rolCostBdM[role] == NU) rolCostBdM[role]=sessDestruct; else if (sessDestruct &lt; rolCostBdM[role]) rolCostBdM[role]=sessDestruct; }
           }

	 	}

        // min cost of mandatory roles compromissions and count of compromisable OK roles
        for(role : int[0,diMr-1] ) if ( node.RoleParams[role][0]!=rS and node.RoleParams[role][1]!=NU ) { //no system and no tranparent roles
            if ( node.RoleParams[role][1]==1 ) { // mandatory role  
                if (not rolOk[role] ) return 0; // peer Position  not available or in non F state
                if (rolCostBdM[role]!=NU) {
                    if ( (tcost==NU) or (rolCostBdM[role]&lt;tcost) ) tcost=rolCostBdM[role]; // minimal cost of  the compromissions of the mandatory role =&gt; tcost 
                }            
            } else if (node.RoleParams[role][1]==0) if (rolOk[role]) nbOKnMand++;          
        }

        if ( nbOKnMand &lt; node.actThreshold ) return 0; // not enough of non mandatory roles are active

        nbtocomp=1+nbOKnMand-node.actThreshold; // number of opeional role necessary to compromise

        // minimal cost of the non mandatory roles' compromission
        for(k : int[0,diMr-1] ) {
          int tr1=NU, j=NU;
          //choice of a role with the minimal cost 
          for(role : int[0,diMr-1] ) if ( (node.RoleParams[role][0]!=rS) and (node.RoleParams[role][1]==0) and (rolCostBdM[role] != NU) and (tr&lt;nbtocomp) )  { //only non mandatory roles
            if ( (tr1==NU) or (tr1&gt;rolCostBdM[role]) )  { tr1=rolCostBdM[role]; j=role; } // role of min cost
          }
          if (tr1!=NU) { tr++; bdCost = (bdCost!=NU)?bdCost:0 + tr1; rolCostBdM[j]=NU; }
        }     
        if (tr &lt; nbtocomp) return tcost; // impossible to comproomise enough of no mandatory roles
        if (tcost==NU) return bdCost;    // it was impossible to compromise mandatory roles  
        return bdCost&gt;tcost?tcost:bdCost; // choice between costs of mandatory or non mandatory role compromissions 
    }



	int NoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {  // true if essential producers present on peer position or if necessary min of comm destruction by malwares!!!!
        int NoProducerDispCost, suppl=0;
        if (fallback and  not isFallBackActiv(node_id,sN) ) return NU;
        if ( (not fallback) and  isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        NoProducerDispCost=minNonDispCost();
        if (NoProducerDispCost == NU) return NU;
        NoProducerDispCost+=suppl;
        if ( (NoProducerDispCost+costs)&lt;= maxCosts ) return NoProducerDispCost;
        return NU;
	}
	
    void updateNoProducerDisp(int[NU,nbNodes-1] node_id, bool fallback) {
        int suppl=0;
        int NoProducerDispCost=minNonDispCost();
        if ( (not fallback) and isFallBackActiv(node_id,sN) ) suppl=node.AnomDetParam[sN-1];
        costs += NoProducerDispCost+suppl;
        if (not fallback) nodeState[node_id].locat=sN;
    }


	int[NU,MaxUnitCost] MinCostMalware(int[NU,nbNodes-1] node_id,int[0,NbStates-1] target_state, bool fallback) {  // malware on input or bad data et peer (partner) position  
	    int cost=NU,tcost=NU, suppl=0;
        if ((node.node_type==cK) and (target_state==sB)) return NU;
        if (fallback and not isFallBackActiv(node_id,target_state) ) return NU;
        if ( (not fallback) and isFallBackActiv(node_id,target_state)) suppl=node.AnomDetParam[target_state-1];
	    if (NbInputs &lt;=0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if ( (nodeState[node.in[i].node_id].locat==sM) or ( (nodeState[node.in[i].node_id].locat==sB) and (node.in[i].attack_position==peer) )) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position);

            if (tcost&gt;NU and node.RoleParams[role][2+target_state]&gt;NU) tcost+=node.RoleParams[role][2+target_state]; else tcost=NU;  // 3 cost for full malware, 4 malware BD only, 5 malware N only

            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost =tcost; 
		}
        if (cost&lt;=NU) return NU;
        cost+=suppl;
	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void updateMalware(int[NU,nbNodes-1] node_id, int[0,NbStates-1] target_state, bool fallback) {
	    int[NU,MaxUnitCost] tmp=MinCostMalware(node_id,target_state, fallback);
	    if (tmp &gt;0) costs=costs+tmp;
	    if (not fallback) nodeState[node_id].locat=target_state;
	}
	

	int[NU,MaxUnitCost] RemoteSecrCost(int[NU,nbNodes-1] node_id) {  // malware on inputs try to steal all locally stored secrets 
	    int cost=NU,tcost=NU,z=0;
	    if (NbInputs &lt;=0) return NU;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) z++;
        if (z==0) return NU;
	 	for(i : int[0,diM-1] ) if (reachable(i)) if (nodeState[node.in[i].node_id].locat==sM) {
            int[0,diMr-1] role = node.in[i].roleId;
            int[NU,2] attack_position=node.in[i].attack_position;
            tcost=ProtProtectCost(i,role,node.in[i].node_id,attack_position); //protocol access cost
            if (tcost&gt;NU and node.RoleParams[role][6]&gt;NU) tcost+=node.RoleParams[role][6];else tcost=NU;
            if (tcost&gt;NU) if ( (cost==NU) or (tcost&lt;cost) ) cost=tcost; 
		}
        if (cost&lt;=NU) return NU;
 	    if ( (cost+costs)&lt;= maxCosts )	return cost; else return NU;

	}


	void setRemoteSecr(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] tmp=RemoteSecrCost(node_id);
	    if (tmp &gt;0) costs=costs+tmp;
        for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true;
	}

	
	int[NU,maxCosts] LocalVarCost(int[NU,nbNodes-1] node_id) {
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) {
	        if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) {
	            cost=node.secrTheftCost;
	            if ((cost+costs)&lt;=maxCosts) return cost;
                return NU;
	        }
	    };
	    return NU;
	}
	
	void setLocalSecr(int[NU,nbNodes-1] node_id){
	    int[NU,MaxUnitCost] cost;
	    for(i : int[0,nbVar-1] ) if ((!StolenSecrets[i]) and StoredSecrets[node.node_id][i] ) StolenSecrets[i]=true; 
	    cost=node.secrTheftCost;
	    costs=costs+cost;
        return;
	}

    int MinFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) return bd;
        if (bd&lt;0) return mal;
        if (bd&gt;mal) return mal;
        return bd;
    }
    void UpdateFB(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sB,fallback), bd=BadData(node_id,fallback);
        if (mal&lt;0) {updateBadData(node_id,fallback);return;};
        if (bd&lt;0) {updateMalware(node_id,sB,fallback);return;};
        if (bd&gt;mal) {updateMalware(node_id,sB,fallback);return;};
        updateBadData(node_id,fallback);return;
    }

    int MinFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) return noProd;
        if (noProd&lt;0) return mal;
        if (noProd&gt;mal) return mal;
        return noProd;
    }
    void UpdateFN(int[NU,nbNodes-1] node_id, bool fallback) {
        int mal=MinCostMalware(node_id,sN,fallback), noProd=NoProducerDisp(node_id,fallback);
        if (mal&lt;0) {updateNoProducerDisp(node_id,fallback);return;};
        if (noProd&lt;0) {updateMalware(node_id,sN,fallback);return;};
        if (noProd&gt;mal) {updateMalware(node_id,sN,fallback);return;};
        updateNoProducerDisp(node_id,fallback);return;
    }


    int MinFM(int[NU,nbNodes-1] node_id, bool fallback) {
        return MinCostMalware(node_id,sM,fallback);
    }
    void UpdateFM(int[NU,nbNodes-1] node_id, bool fallback) {
        updateMalware(node_id,sM,fallback);return;
    }
		
</declaration>
		<location id="id115" x="-24412" y="-11466" color="#00ff00">
			<name x="-24386" y="-11483">F</name>
		</location>
		<location id="id116" x="-24591" y="-11628" color="#ffa500">
			<name x="-24599" y="-11611">N</name>
		</location>
		<location id="id117" x="-24590" y="-11390" color="#ffa500">
			<name x="-24598" y="-11424">M</name>
		</location>
		<location id="id118" x="-24590" y="-11500" color="#ffa500">
			<name x="-24599" y="-11534">B</name>
		</location>
		<location id="id119" x="-24063" y="-11551">
			<name x="-24046" y="-11559">Start</name>
		</location>
		<location id="id120" x="-24089" y="-11313">
			<name x="-24063" y="-11321">R</name>
		</location>
		<init ref="id119"/>
		<transition id="id121" color="#c0c0c0">
			<source ref="id117"/>
			<target ref="id119"/>
			<label kind="synchronisation" x="-24573" y="-11305">reset?</label>
			<nail x="-24633" y="-11288"/>
			<nail x="-24012" y="-11288"/>
		</transition>
		<transition id="id122" color="#c0c0c0">
			<source ref="id118"/>
			<target ref="id119"/>
			<label kind="synchronisation" x="-24573" y="-11568">reset?</label>
			<nail x="-24616" y="-11551"/>
		</transition>
		<transition id="id123" color="#c0c0c0">
			<source ref="id115"/>
			<target ref="id119"/>
			<label kind="synchronisation" x="-24165" y="-11475">reset?</label>
			<nail x="-24038" y="-11475"/>
		</transition>
		<transition id="id124" color="#c0c0c0">
			<source ref="id116"/>
			<target ref="id119"/>
			<label kind="synchronisation" x="-24514" y="-11687">reset?</label>
			<nail x="-24624" y="-11670"/>
			<nail x="-24063" y="-11670"/>
		</transition>
		<transition id="id125">
			<source ref="id115"/>
			<target ref="id115"/>
			<label kind="guard" x="-24301" y="-11645">(RemoteSecrCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24293" y="-11628">setRemoteSecr(id)</label>
			<nail x="-24140" y="-11645"/>
			<nail x="-24318" y="-11645"/>
		</transition>
		<transition id="id126">
			<source ref="id115"/>
			<target ref="id120"/>
			<label kind="guard" x="-24344" y="-11449">MinFN(id,true)&gt;=0</label>
			<label kind="assignment" x="-24344" y="-11432">UpdateFN(id,true), FallBack(id,sN)</label>
			<nail x="-24225" y="-11432"/>
		</transition>
		<transition id="id127">
			<source ref="id115"/>
			<target ref="id120"/>
			<label kind="guard" x="-24437" y="-11330">MinFM(id,true)&gt;=0</label>
			<label kind="assignment" x="-24437" y="-11313">UpdateFM(id,true), FallBack(id,sM)</label>
			<nail x="-24412" y="-11305"/>
		</transition>
		<transition id="id128">
			<source ref="id120"/>
			<target ref="id119"/>
			<label kind="synchronisation" x="-24106" y="-11356">reset!</label>
		</transition>
		<transition id="id129">
			<source ref="id115"/>
			<target ref="id120"/>
			<label kind="guard" x="-24378" y="-11398">MinFB(id,true)&gt;=0</label>
			<label kind="assignment" x="-24378" y="-11381">UpdateFB(id,true), FallBack(id,sB)</label>
			<nail x="-24293" y="-11347"/>
		</transition>
		<transition id="id130" color="#c0c0c0">
			<source ref="id119"/>
			<target ref="id118"/>
			<label kind="guard" x="-24361" y="-11577">nodeState[id].locat==sB</label>
			<label kind="synchronisation" x="-24361" y="-11560">startCh?</label>
			<nail x="-24157" y="-11568"/>
		</transition>
		<transition id="id131" color="#a9a9a9">
			<source ref="id119"/>
			<target ref="id115"/>
			<label kind="guard" x="-24344" y="-11543">nodeState[id].locat==sF</label>
			<label kind="synchronisation" x="-24344" y="-11526">startCh?</label>
			<nail x="-24361" y="-11517"/>
		</transition>
		<transition id="id132" color="#c0c0c0">
			<source ref="id119"/>
			<target ref="id116"/>
			<label kind="guard" x="-24267" y="-11602">nodeState[id].locat==sN</label>
			<label kind="synchronisation" x="-24140" y="-11585">startCh?</label>
			<nail x="-24131" y="-11585"/>
		</transition>
		<transition id="id133" color="#c0c0c0">
			<source ref="id119"/>
			<target ref="id117"/>
			<label kind="guard" x="-24344" y="-11500">nodeState[id].locat==sM</label>
			<label kind="synchronisation" x="-24208" y="-11517">startCh?</label>
			<nail x="-24157" y="-11517"/>
		</transition>
		<transition id="id134">
			<source ref="id117"/>
			<target ref="id117"/>
			<label kind="guard" x="-24573" y="-11373">(LocalVarCost(id)&gt;=0)</label>
			<label kind="assignment" x="-24573" y="-11356">setLocalSecr(id)</label>
			<nail x="-24591" y="-11347"/>
			<nail x="-24497" y="-11381"/>
		</transition>
		<transition id="id135">
			<source ref="id115"/>
			<target ref="id118"/>
			<label kind="guard" x="-24566" y="-11509">MinFB(id,false)&gt;=0</label>
			<label kind="assignment" x="-24566" y="-11492">UpdateFB(id,false)</label>
		</transition>
		<transition id="id136">
			<source ref="id115"/>
			<target ref="id116"/>
			<label kind="guard" x="-24565" y="-11619">MinFN(id,false)&gt;=0</label>
			<label kind="assignment" x="-24565" y="-11602">UpdateFN(id,false)</label>
			<nail x="-24412" y="-11628"/>
		</transition>
		<transition id="id137">
			<source ref="id115"/>
			<target ref="id117"/>
			<label kind="guard" x="-24573" y="-11433">MinFM(id,false)&gt;=0</label>
			<label kind="assignment" x="-24573" y="-11416">UpdateFM(id,false)</label>
		</transition>
	</template>
	<template>
		<name>Start</name>
		<location id="id138" x="-76" y="-68">
			<name x="-86" y="-102">Running</name>
		</location>
		<location id="id139" x="-306" y="-93">
			<name x="-316" y="-127">Start</name>
		</location>
		<init ref="id139"/>
		<transition id="id140">
			<source ref="id138"/>
			<target ref="id139"/>
			<label kind="guard" x="-177" y="-140">true</label>
			<label kind="synchronisation" x="-177" y="-123">reset?</label>
			<nail x="-187" y="-136"/>
		</transition>
		<transition id="id141">
			<source ref="id139"/>
			<target ref="id138"/>
			<label kind="guard" x="-179" y="-98">true</label>
			<label kind="synchronisation" x="-212" y="-85">startCh!</label>
		</transition>
	</template>
	<system>// Place template instantiations here.

Browser=Browsert(0);Hacker=Hackert(1);HttpSrv=HttpSrvt(2);Linux=Linuxt(3);Routing=Routingt(4);Windows=Windowst(5); // all processeses
Go=Start();

// List one or more processes to be composed into a system.
system   Browser,Hacker,HttpSrv,Linux,Routing,Windows&lt;Go;  // the Go process has a higher priority</system>
	<queries>
		<query>
			<formula>E&lt;&gt; ( IoTFront.B )</formula>
			<comment/>
		</query>
		<query>
			<formula>E&lt;&gt; (StolenSecrets[4]==true)</formula>
			<comment/>
		</query>
		<query>
			<formula>inf{IoTFront.B}: costs </formula>
			<comment/>
		</query>
		<query>
			<formula>inf{StolenSecrets[4]==true}: costs</formula>
			<comment/>
		</query>
	</queries>
</nta>
